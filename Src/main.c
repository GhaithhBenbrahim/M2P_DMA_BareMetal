/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#include "stm32f407xx.h"

void button_init(void);
void uart2_init(void);
void send_some_data(void);
void dma1_init(void);
void Enable_DMA1_Stream6(void);

void DMA1_Interrupt_Configuration(void);

//function prototypes of the callbacks
void HT_Complete_callback(void);
void FT_Complete_callback(void);
void TE_error_callback(void);
void DME_error_callback(void);
void FE_error_callback(void);

char data_stream[] = "Hello Esp32 from STM32 \r\n";

int main(void)
{
	//no need for clock init default 16mhz
	button_init();
	uart2_init();

	dma1_init();
	DMA1_Interrupt_Configuration();
	Enable_DMA1_Stream6();


	return 0 ;
}

void send_some_data(void)
{
	USART_TypeDef *pUART2;
	pUART2 = USART2;

	char somedata[] = "hello World \r\n";

	//make sure that in the status register txe is set
	//if TXE is 1, put the byte

	uint32_t len = sizeof(somedata);

	for(uint32_t i = 0  ; i < len ; i++ )
	{
		while ( !(pUART2->SR & (1<<7))) ;

		pUART2->DR = somedata[i]	;
	}

}


void button_init(void)
{
	//button is connected to PA0 GPIOA pin number 0
	GPIO_TypeDef *pGPIOA ;
	pGPIOA = GPIOA;

	RCC_TypeDef *pRCC;
	pRCC = RCC;

	EXTI_TypeDef *pEXTI;
	pEXTI = EXTI;

	SYSCFG_TypeDef *pSYSCFG;
	pSYSCFG = SYSCFG;

	//1. enable the clock for the GPIOA peripheral
	pRCC->AHB1ENR = (1 << 0);

	//2. keep the GPIO pin in input mode
	pGPIOA->MODER &= ~(0x3 << 0);

	//3. Enable the interrupt
	pEXTI->IMR |= (1 << 0);

	//4. Enable the clock for the SYSCFG
	pRCC->APB2ENR |= ( 1 << 14);

	//5. Configure the SYSCFG CR4 register
	pSYSCFG->EXTICR[0] &= ~(0xF << 0);
	pSYSCFG->EXTICR[0] |=  (0x0 << 0);

	//6. Configure the edge detection on that pin
	pEXTI->FTSR |= (1 << 0);

	//7. Enable the IRQ related to that GPIO pin in NVIC of the processor
	NVIC_EnableIRQ(EXTI0_IRQn);

}

void uart2_init(void)
{
	RCC_TypeDef *pRCC;
	pRCC = RCC;

	GPIO_TypeDef *pGPIOA ;
	pGPIOA = GPIOA;

	USART_TypeDef *pUART2;
	pUART2 = USART2;

	//1. enable the peripheral clock for the uart2 peripheral
	pRCC->APB1ENR |= (1 << 17);

	//2. configure the gpio pins for uart_tx and uart_rx functions
	// PB6 TX PB7 RX
	//2.1 Enable the clock for the GPIOA
	pRCC->AHB1ENR = (1 << 0);

	//2.2 Change the mode of the PA2 to alternate function mode
	pGPIOA->MODER &= ~ (0x3 << 4) ;
	pGPIOA->MODER |=   (0x2 << 4) ;

	pGPIOA->AFR[0] &= ~(0xF << (2*4)) ; // Clear AFR
	pGPIOA->AFR[0] |=  (0x7 << (2*4)) ;

	//2.3 Enable or disable Pull-up resistor if required
	pGPIOA->PUPDR |= (0x1 << (2*2)) ;

	//2.4 Change the mode of the PA3 to alternate function mode
	pGPIOA->MODER &= ~ (0x3 << 6) ;
	pGPIOA->MODER |=   (0x2 << 6) ;

	pGPIOA->AFR[0] &= ~(0xF << (3*4)) ; // Clear AFR
	pGPIOA->AFR[0] |=  (0x7 << (3*4)) ;

	//2.5 Enable or disable Pull-up resistor if required
	pGPIOA->PUPDR |= (0x1 << (3*2)) ;

	//3. configure the baudrate
	pUART2->BRR = 0x8B;

	//4. configure the data width, no of stop bits parity ect..
	/* <no Configuration needed we'l use the default one >*/

	//5. Enable the TX engine of the uart peripheral
	pUART2->CR1 |= (1 << 3);

	//6. enable the uart peripheral
	pUART2->CR1 |= (1 << 13);

}

void dma1_init(void)
{
	RCC_TypeDef *pRCC;
	pRCC = RCC;

	DMA_Stream_TypeDef *pSTREAM6;
	pSTREAM6 = DMA1_Stream6 ;

	USART_TypeDef *pUART2;
	pUART2 = USART2;

	//1. enable the peripheral clock for the dma
	pRCC->AHB1ENR |= (1 << 21);

	//2. identify the stream which is suitable for your peripheral
	   //chnnel 4 , stream 6

	//3. identify the number on which uart2 peripheral sends dma request to
	   //channel 4
	pSTREAM6->CR &= ~(0x7 << 25);
	pSTREAM6->CR |=  (0x4 << 25);

	//4. program the source address (memory)
	pSTREAM6->M0AR = (uint32_t) data_stream ;

	//5. program the destination address
	pSTREAM6->PAR = (uint32_t) &pUART2->DR ;

	//6. program number of data item to send
	uint32_t len = sizeof(data_stream);

	pSTREAM6->NDTR = len ;

	//7. The direction of data transfer . m2m p2m m2p
	pSTREAM6->CR |= (0x1 << 6);

	//8. Program the source and destination data width.
	pSTREAM6->CR &= ~(0x3 << 13);
	pSTREAM6->CR &= ~(0x3 << 11);

	//9.enable memory increment
	pSTREAM6->CR |= (1 << 10);

	//10. Select direct mode or fifo mode
	pSTREAM6->FCR |= (1 << 2);

	//11. Select the fifo threshold
	pSTREAM6->FCR &= ~(0x3 << 0);
	pSTREAM6->FCR |=  (0x3 << 0);

	//12. Enable the circular mode if required

	//13. single transfer or burst transfer

	//14. Configure the stream priority

}

void Enable_DMA1_Stream6(void)
{
	DMA_Stream_TypeDef *pSTREAM6;
	pSTREAM6 = DMA1_Stream6 ;

	//15. Enable the stream
	pSTREAM6->CR |= (1 << 0);
}


void DMA1_Interrupt_Configuration(void)
{
	DMA_Stream_TypeDef *pSTREAM6;
	pSTREAM6 = DMA1_Stream6 ;

	// 1. Half transfer IE (HTIE)
	pSTREAM6->CR |= (1 << 3);

	// 2. Transfer complete IE (TCIE)
	pSTREAM6->CR |= (1 << 4);

	// 3. Transfer error IE (TEIE)
	pSTREAM6->CR |= (1 << 2);

	//4. FIFO overrun/underrun IE (FEIE)
	pSTREAM6->FCR |= (1 << 7);

	//5. Direct mode error (DMEIE)
	pSTREAM6->CR |= (1 << 1);

	//6. Enable the IRQ for the DMA1 stream6 global interrupt in NVIC
	NVIC_EnableIRQ(DMA1_Stream6_IRQn);

}

void HT_Complete_callback(void)
{

}

void FT_Complete_callback(void)
{
	USART_TypeDef *pUART2;
	pUART2 = USART2;

	DMA_Stream_TypeDef *pSTREAM6;
	pSTREAM6 = DMA1_Stream6;

	//Program number of data items to send
	uint32_t len = sizeof(data_stream);
	pSTREAM6->NDTR = len;

	pUART2->CR3 &= ~( 1 << 7);

	Enable_DMA1_Stream6();

	//pUART2->CR3 |= ( 1 << 7);

}


void TE_error_callback(void)
{
	while(1);
}

void FE_error_callback(void)
{

	while(1);
}

void DME_error_callback(void)
{
	while(1);
}


























